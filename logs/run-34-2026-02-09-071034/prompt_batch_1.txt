Fix 1 CodeQL security issue(s) in https://github.com/marius-posa/codeql-devin-fixer (branch: main).

Issue IDs: CQLF-R34-0001
Category: injection | Severity: CRITICAL (max CVSS: 9.8)

## Playbook: injection (v1)

Fix pattern for SQL injection and command injection vulnerabilities. Covers CWE-89 (SQL injection), CWE-78 (OS command injection), CWE-94 (code injection), and related injection families.

Follow these steps in order:

### Step 1: Identify all entry points for tainted data

Trace the data flow backwards from the vulnerable sink to find every
entry point where user-controlled data enters the application:
- HTTP request parameters (query strings, form bodies, headers, cookies)
- File uploads and file-read paths
- Database fields that were previously stored from user input
- Environment variables or configuration values sourced externally
- WebSocket messages, message queue payloads, or IPC inputs

For each entry point, note:
1. The variable name and type
2. Whether any validation or sanitization is already applied
3. All intermediate transformations before the data reaches the sink

### Step 2: Apply the canonical fix pattern

For SQL injection (CWE-89):
- Replace string concatenation / f-strings / template literals with
  parameterized queries or prepared statements.
- Use the ORM's built-in query builder when available (e.g.,
  SQLAlchemy's `text(:param)`, Django's QuerySet API, Sequelize
  placeholders).
- If raw SQL is required, use the database driver's parameter binding
  (e.g., `cursor.execute("SELECT * FROM t WHERE id = %s", (user_id,))`).
- Never use string formatting to build WHERE, ORDER BY, or LIMIT clauses.

For OS command injection (CWE-78):
- Replace `os.system()`, `subprocess.run(shell=True)`, or backtick
  execution with safe APIs that accept argument lists:
  `subprocess.run(["cmd", arg1, arg2], shell=False)`.
- Use `shlex.quote()` if shell invocation is truly unavoidable.
- Validate inputs against a strict allowlist of permitted values.

For code injection (CWE-94):
- Remove or replace `eval()`, `exec()`, `Function()`, `setTimeout(string)`.
- Use a sandboxed execution environment if dynamic evaluation is needed.
- Parse structured data with JSON/YAML parsers instead of evaluating it.

### Step 3: Run the existing test suite

Run the project's full test suite to confirm the fix does not break
existing functionality:
- Identify the test runner (pytest, jest, mocha, go test, etc.)
- Run all tests and verify they pass
- Pay special attention to tests in the same module/package as the
  changed files
- If any tests fail, determine whether the failure is caused by the
  fix (adjust the fix) or is a pre-existing issue (note it in the PR)

### Step 4: Add a test case that would have caught the vulnerability

Write at least one test that:
- Sends malicious input through the identified entry point (e.g.,
  `' OR 1=1 --` for SQL injection, `; cat /etc/passwd` for command
  injection)
- Asserts that the malicious payload is NOT executed or interpreted
- Verifies the application returns a safe result or appropriate error
- If the project uses an ORM, add a test that verifies parameterized
  query usage (e.g., by inspecting the generated SQL or using a mock)


Historical fix rate for injection: 100% (1/1 sessions completed)

Issues to fix:

### CQLF-R34-0001: py/command-line-injection (py/command-line-injection)
- Severity: CRITICAL (9.8)
- CWE: cwe-78, cwe-88
- Location(s): github_app/scan_trigger.py:164
- Description: This command line depends on a [user-provided value](1).
- Rule: Uncontrolled command line
- Guidance: # Uncontrolled command line
Code that passes user input directly to `exec`, `eval`, or some other library routine that executes a command, allows the user to execute malicious code.


## Recommendation
If possible, use hard-coded string literals to specify the command to run or the library to load. Instead of passing the user input directly to the process or library function, examine the user input and then choose among hard-coded string literals.

If the applicable libraries or commands cannot
- Code context:
```
     159 |                 "clone", "--depth", "1", "--single-branch",
     160 |             ]
     161 |         cmd.extend(["--", repo_url, clone_dir])
     162 | 
     163 |         result = subprocess.run(
>>>  164 |             cmd,
     165 |             env=clone_env,
     166 |             capture_output=True,
     167 |             text=True,
     168 |             timeout=300,
     169 |         )
```

Instructions:
1. Clone https://github.com/marius-posa/codeql-devin-fixer and create a new branch from main.
2. Fix ALL the issues listed above. Track which issue IDs you are fixing.
3. Ensure fixes don't break existing functionality.
4. Run existing tests if available to verify.
5. Create a PR on https://github.com/marius-posa/codeql-devin-fixer with a clear description listing each issue ID fixed.
6. Title the PR exactly: 'fix(CQLF-R34-0001): resolve injection security issues'
7. In the PR body, list each issue ID (CQLF-R34-0001) and describe the fix applied.

Files to focus on:
- github_app/scan_trigger.py

## Playbook Improvement Request

You used the **injection** playbook (v1) to fix the issues above. Based on your experience applying it to this codebase, please suggest improvements.

In your PR description, include a section titled **"Playbook Improvements"** with:
- Any steps that were unclear or missing context
- Additional sub-steps that would help future fixes
- Language- or framework-specific tips you discovered
- Steps that were unnecessary or redundant

Format each suggestion as:
```
STEP: <step_id>
SUGGESTION: <your improvement>
```

These suggestions will be reviewed and merged into the playbook for future sessions.
